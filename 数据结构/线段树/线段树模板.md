线段树模板（求区间和）
```c++
template<typename T>
class segment_tree
{
private:
	vector<T>tree;
	vector<T>lazy;
	T zero;
	inline void down(int k, int len)
	{
		lazy[k << 1] += lazy[k];
		lazy[k << 1 | 1] += lazy[k];
		tree[k << 1] += lazy[k] * (len - (len >> 1));
		tree[k << 1 | 1] += lazy[k] * (len >> 1);
		lazy[k] = zero;
	}
public:
	int size;
	segment_tree(int n) :size(n), zero(T{})
	{
		tree.resize(4 * n + 5);
		lazy.resize(4 * n + 5);
	}
	void build(const T* src = nullptr, int ll = 1, int rr = -1, int k = 1)
	{
		if (rr == -1)
			rr = size;
		if (ll == rr)
		{
			if (src == nullptr)
				cin >> tree[k];
			else
				tree[k] = src[k];
			return;
		}
		int mid = (ll + rr) >> 1;
		build(ll, mid, k << 1);
		build(mid + 1, rr, k << 1 | 1);
		tree[k] = tree[k << 1] + tree[k << 1 | 1];
	}
	void modify(const int l, const int r, const T value, int ll = 1, int rr = -1, int k = 1)
	{
		if (rr == -1)
			rr = size;
		if (ll >= l && rr <= r)
		{
			tree[k] += value * (rr - ll + 1);
			lazy[k] += value;
			return;
		}
		if (lazy[k] != zero)
			down(k, rr - ll + 1);
		int mid = (ll + rr) >> 1;
		if (r > mid)
			modify(l, r, value, mid + 1, rr, k << 1 | 1);
		if (l <= mid)
			modify(l, r, value, ll, mid, k << 1);
		tree[k] = tree[k << 1] + tree[k << 1 | 1];
	}
	T query(const int l, const int r, int ll = 1, int rr = -1, int k = 1)
	{
		if (rr == -1)
			rr = size;
		if (ll >= l && rr <= r)
			return tree[k];
		if (lazy[k] != zero)
			down(k, rr - ll + 1);
		int mid = (ll + rr) >> 1;
		T ans{};
		if (r > mid)
			ans += query(l, r, mid + 1, rr, k << 1 | 1);
		if (l <= mid)
			ans += query(l, r, ll, mid, k << 1);
		return ans;
	}
};

```

