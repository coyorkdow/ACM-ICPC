## 最小费用最大流(Dijkstra&Bellman实现)



```c++
template <
	class _EW = int, class _EC = int, class _TW = long long, class _TC = long long>
class mcmf {
private:
	_TC inf, *dis, *h;;
	_EW minf;
	int S, T, size, *ptr;
	vector<vector<int>> &G;
	bool always_bellman;
	bitset<(int)2e5> vis;
	const double eps;
	bool dijkstra() {
		priority_queue<heapnode> Q;
		memset(dis, 0x4f, sizeof(_TC) * (maxn + 5));
		dis[S] = 0;
		Q.push(heapnode(S, 0));
		register _TC tmp;
		while (!Q.empty()) {
			heapnode cur = Q.top();
			Q.pop();
			if (dis[cur.id] < cur.w)
				continue;
			for (vector<int>::iterator it = G[cur.id].begin(); it != G[cur.id].end(); it++) {
				edge &e = E[*it];
				if (!e.cap)
					continue;
				tmp = h[cur.id] + e.cost - h[e.to] + dis[cur.id];
				if (tmp < dis[e.to] - eps) {
					dis[e.to] = tmp;
					Q.push(heapnode(e.to, tmp));
				}
			}
		}
		return fabs(dis[T] - inf) > eps;
	}
	bool bellman() {
		deque<int> Q;
		memset(dis, 0x4f, sizeof(_TC) * (maxn + 5));
		dis[S] = 0;
		Q.push_back(S);
		vis.set(S);
		register _TC tmp;
		while (!Q.empty()) {
			int cur = Q.front();
			Q.pop_front();
			vis.reset(cur);
			for (vector<int>::iterator it = G[cur].begin(); it != G[cur].end(); it++) {
				edge &e = E[*it];
				if (!e.cap)
					continue;
				tmp = e.cost + dis[cur];
				if (tmp < dis[e.to] - eps) {
					dis[e.to] = tmp;
					if (vis.test(e.to))
						continue;
					vis.set(e.to);
					if (!Q.empty() && dis[Q.front()] < tmp)
						Q.push_back(e.to);
					else
						Q.push_front(e.to);
				}
			}
		}
		vis.reset();
		return fabs(dis[T] - inf) > eps;
	}
	_EW dfs(int cur, const _EW flow) {
		if (cur == T)
			return flow;
		_EW res = flow, add{};
		vis.set(cur);
		register int size = G[cur].size();
		for (; ptr[cur] < size; ptr[cur]++) {
			edge &e = E[G[cur][ptr[cur]]];
			if (!vis.test(e.to) && fabs(dis[cur] + h[cur] + e.cost - h[e.to] - dis[e.to]) <= eps && e.cap) {
				add = dfs(e.to, res < e.cap ? res : e.cap);
				e.cap -= add;
				E[G[cur][ptr[cur]] ^ 1].cap += add;
				res -= add;
				if (res < eps)
					break;
			}
		}
		vis.reset(cur);
		return flow - res;
	}
public:
	int maxn;
	bool negative;
	struct edge {
		int to;
		_EW cap;
		_EC cost;
	};
	vector<edge> E;
	struct heapnode {
		int id;
		_TC w;
		bool operator<(const heapnode &t) const {
			return w > t.w;
		}
		heapnode(int _id, _TC _w) : id(_id), w(_w) {}
	};
	mcmf(int n, vector<int> *_g, int *_ptr, _TC *_dis, _TC *_h)
		: maxn(n), size(0), G(_g), ptr(_ptr), dis(_dis), h(_h), 
		negative(false), always_bellman(false), eps(1e-6) {
		memset(&inf, 0x4f, sizeof(_TC));
		memset(&minf, 0x4f, sizeof(_EW));
	}
	inline void use_bellman(bool t) { always_bellman = t; }
	void reset(int n) {
		maxn = n;
		for (register int i = 0; i <= n; i++)
			G[i].clear();
		E.clear();
		memset(ptr, 0, sizeof(int) * (maxn + 5));
		memset(h, 0, sizeof(_TC) * (maxn + 5));
		negative = false;
		size = 0;
	}
	inline int add_edge(const int &u, const int &v, const _EW &cap, const _EC &cost) {
		if (cost < 0)
			negative = true;
		G[u].push_back(size++);
		G[v].push_back(size++);
		E.push_back(edge{v, cap, cost});
		E.push_back(edge{u, 0, -cost});
		return size - 2;
	}
	pair<_TC, _TW> get_mcmf(const int &s, const int &t) {
		S = s, T = t;
		_TW mf{};
		_TC mc{};
		register _TW flow;
		if (always_bellman) {
			while (bellman()) {
				memset(ptr, 0, sizeof(int) * (maxn + 5));
				flow = dfs(s, minf);
				mf += flow;
				mc += flow * dis[t];
			}
			return make_pair(mc, mf);
		}
		if (negative) {
			bellman();
			memset(ptr, 0, sizeof(int) * (maxn + 5));
			flow = dfs(s, minf);
			for (int i = 0; i <= maxn; i++)
				h[i] = min(h[i] + dis[i], inf);
			mf += flow;
			mc += flow * dis[t];
		}
		while (dijkstra()) {
			memset(ptr, 0, sizeof(int) * (maxn + 5));
			flow = dfs(s, minf);
			for (int i = 0; i <= maxn; i++)
				h[i] = min(h[i] + dis[i], inf);
			mf += flow;
			mc += flow * h[t];
		}
		return make_pair(mc, mf);
	}
};
```

